% CU CS5525
% Fall 2012
% Python Compiler
%
% proposal.tex
% Semester Project Proposal
%
% Repository:
%    https://github.com/asayler/CU-CS5525-PythonCompiler
%
% By :
%    Anne Gatchell
%       http://annegatchell.com/
%    Andy Sayler
%       http://www.andysayler.com
%    Michael (Mike) Vitousek
%       http://csel.cs.colorado.edu/~mivi2269/

\documentclass[11pt]{article}

\usepackage[text={6.5in, 9in}, centering]{geometry}
\usepackage{graphicx}
\usepackage{url}
\usepackage{listings}
\usepackage{hyperref}

\bibliographystyle{plain}

\hypersetup{
    colorlinks,
    citecolor=black,
    filecolor=black,
    linkcolor=black,
    urlcolor=black
}

\lstset{
  language={},
  basicstyle=\footnotesize,
  numbers=left,
  numberstyle=\tiny,
  stepnumber=1,
  numbersep=5pt,
  showspaces=false,
  showstringspaces=false,
  showtabs=false,
  tabsize=4,
  captionpos=b,
  breaklines=true,
  breakatwhitespace=false,
  frame=single,
  frameround=tttt
}

\lstdefinelanguage{llvm}{
  morecomment = [l]{;},
  morestring=[b]'', 
  sensitive = true,
  classoffset=0,
  morekeywords={
    define, declare, global, constant,
    internal, external, private,
    linkonce, linkonce_odr, weak, weak_odr, appending,
    common, extern_weak,
    thread_local, dllimport, dllexport,
    hidden, protected, default,
    except, deplibs,
    volatile, fastcc, coldcc, cc, ccc,
    x86_stdcallcc, x86_fastcallcc,
    ptx_kernel, ptx_device,
    signext, zeroext, inreg, sret, nounwind, noreturn,
    nocapture, byval, nest, readnone, readonly, noalias, uwtable,
    inlinehint, noinline, alwaysinline, optsize, ssp, sspreq,
    noredzone, noimplicitfloat, naked, alignstack,
    module, asm, align, tail, to,
    addrspace, section, alias, sideeffect, c, gc,
    target, datalayout, triple,
    blockaddress
  },
  classoffset=1,
  morekeywords={
    fadd, sub, fsub, mul, fmul,
    sdiv, udiv, fdiv, srem, urem, frem,
    and, or, xor,
    icmp, fcmp,
    eq, ne, ugt, uge, ult, ule, sgt, sge, slt, sle,
    oeq, ogt, oge, olt, ole, one, ord, ueq, ugt, uge,
    ult, ule, une, uno,
    nuw, nsw, exact, inbounds,
    phi, call, select, shl, lshr, ashr, va_arg,
    trunc, zext, sext,
    fptrunc, fpext, fptoui, fptosi, uitofp, sitofp,
    ptrtoint, inttoptr, bitcast,
    ret, br, indirectbr, switch, invoke, unwind, unreachable,
    malloc, alloca, free, load, store, getelementptr,
    extractelement, insertelement, shufflevector,
    extractvalue, insertvalue,
  },
  alsoletter={\%},
  keywordsprefix={\%},
}

\newenvironment{packed_enum}{
\begin{enumerate}
  \setlength{\itemsep}{1pt}
  \setlength{\parskip}{0pt}
  \setlength{\parsep}{0pt}
}{\end{enumerate}}

\newenvironment{packed_item}{
\begin{itemize}
  \setlength{\itemsep}{1pt}
  \setlength{\parskip}{0pt}
  \setlength{\parsep}{0pt}
}{\end{itemize}}

\begin{document}

\title{
  Building a LLVM Python Compiler
}

\author{
  Anne Gatchell \and Andrew Sayler \and Michael Vitousek\\
  University of Colorado\\
  \texttt{first.last@colorado.edu}
}

\date{\today}

\maketitle

\newpage

\section{Problem Statement}

While the existing HW6, P3-compliant compiler supports 32-bit,
x86 code generation, it does not support generating code for the variety
of non-x86 architectures and assembly languages common today (x64, ARM,
etc). While we could remedy
this deficiency by adding additional native code generation for non-x86
architectures directly to our compiler, this approach would duplicate a
wide range of existing effort, force us to work in assembly languages
with which we are not experts, and would require continued maintain to
support new architectures and assembly languages as they arise.

Instead, we aim to leverage the existing work done by the LLVM project to
convert our HW6 compiler from an x86 targeted compiler to
an LLVM targeted compiler. We will maintain the current x86 targeting
and add LLVM intermediate form as an additional targeting option. In
this way, we will be able to compare our natively generated x86 code
with the LLVM-assembler generated x86 code. We will also be able to
experiment with compiling our LLVM intermediate form files to assembly
languages other than x86 such as x64 and ARM.

LLVM is quickly becoming the de facto standard target for most modern
compilers and high level languages.
It provides mutli-platform support, multi-runtype support
(compiled, interpreted, JIT compiled, etc), and access to a
range of existing optimization tools and techniques. Through this
project, we hope to become
familiar with the LLVM intermediate form and LLVM system architecture
while gaining insight into the benefits of building an LLVM-targeted
compiler. 

\section{Approach}

% Mention something about the various steps involved. I.e. add support
% for SSA form, add LLVM instruction nodes, add LLVM instruction
% selection, convert Makefile to support LLVM builds, investigate
% compiling runtime functions to LLVM and linking in LLVM, comparing
% LLVM performance vs x86 performance, playing with non-x86 LLVM
% targets, playing with various LLVM runtypes, etc
The primary goal will be to add support to enable compilation to the
LLVM assembly language.  We will need to add new intermediate LLVM
instruction nodes to our compiler that will lend themselves to the
LLVM format. A key aspect for us to investigate is how we compile our
runtime functions and link them to our intermediate representation
output.  We will need to alter our Makefile to allow for both the x86
compilation and the LLVM compilation to be run. Since it will be
interesting to analyze the performance differences between our x86
representation and our LLVM representation, we will also need to add
support for recording and comparing runtimes for the compiled
programs.  We would also like to test our implementation on non-x86
targets, so that we can demonstrate the benefit and universality of
using LLVM.

\section{Design}

% Mention keeping most of the re-factored HW6, p3 design, but changing
% instruction selection, ability to forgo register allocation, need to
% add SSA form conversion pass, etc
We have been working on refactoring the HW6, and we plan on keeping
the refactored design, along with the design of p3. The most major
changes will happen as we change instruction selection and forego
register allocation. A significant difference between our current x86
compiler and our projected LLVM compiler is that the LLVM compiler
uses variable names in its instructions, much like our current p3
compiler is at the state prior to register allocation. So, instruction
selection and the intermediate nodes will need to be altered to lend
themselves to the LLVM format.

We will need to add a pass in our compiler that will convert to the
SSA format, meaning that each variable is assigned to exactly once. In
many ways, this will be similar to our Flatten pass.

Since LLVM is a typed representation, so we will need to incorporate
this information into our representation, which will require a fresh
look at the interaction of the runtime functions and our compiler
pass. Since verb{struct} type definition is allowed in LLVM, perhaps
we will define types for pyobjs to deal with the typing issue and
allow us to still link to our runtime functions a similar way.  This
also might mean that we can do away with the bit manipulation in the
runtime functions in favor of introspection on LLVM structs, allowing
us to keep a higher precision for our integers, since the flag would
just be an 8 bit integer in the pyobj struct.

All in all, there are many similarities between our current
implementation and LLVM, but the typing and linking will be
significant factors to address.

For reference, below is an LLVM hello world program, taken from the
LLVM Reference Manual.

\lstinputlisting[
  language=llvm,
  label=lst:llvm-example_hell0.ll,
  caption={LLVM Assembly - Hello World Example}
]{../code/llvm-examples/hello0.ll}

\section{Deliverables}

% 1. Basic SSA form support with native x86 code
% 2. Basic LLVM instruction selection support
% 3. Pass all current test cases using LLVM
% 4. (if time) Compare LLVM performance to native x86 performance
% 5. (if time) Compare LLVM runtypes (interpreted, compiled, etc)
% 6. (if time) Test LLVM implementation on x64 and ARM architectures
% 7. (if time) Look into adding LLVM optimization for typing, JIT, etc


\nocite{*} \bibliography{refs}

% If anyone finds one, we could use one or more good SSA reference in
% the bibtek file. Also, the more LLVM reference, tutorials, etc the
% better. Maybe the original LLVM papers? LLVM ``Hello World''
% examples? Reports on other systems that use LLVM (Apple, Obj-C, etc)?

\end{document}
